---
# Invoke with (example):
#- set_fact:
#    backup_inline_script: >-
#      (date; uname -a) | gzip
#    backup_destination_file: "{{ backup_destination_dir }}/date_uname-a.gz"

- name: Assert that "backup_inline_script" and "backup_destination_file" facts are defined and valid
  assert:
    that:
      - backup_inline_script is defined
      - backup_inline_script is string
      - backup_inline_script | length > 0
      - backup_destination_file is defined
      - backup_destination_file is string
      - backup_destination_file | length > 0
    fail_msg: The backup_inline_script and backup_destination_file facts must be defined and both must be non-empty strings.

- name: Download artifacts to mounted storage

  delegate_to: "{{ backup_destination_host }}"

  always:
    - name: Delete generated files
      file:
        path: "{{ item }}"
        state: absent
      loop:
        - "{{ private_key_file.path }}"
        - "{{ private_key_file.path }}.pub"

    - delegate_to: "{{ inventory_hostname }}"  # cancel previous delegate_to
      block:
        - name: Remove public openssh key from admin's authorized_keys
          authorized_key:
            user: "{{ admin_user.name }}"
            state: absent
            key: >-
              {{ openssh_keypair.public_key }}

  block:
    - name: Ensure that .ssh directory exists
      file:
        path: ~/.ssh/
        state: directory

    - name: Create a temporary file path to hold the private key in
      tempfile:
        path: ~/.ssh/
        suffix: .tmp
        state: file
      register: private_key_file

    - name: Generate openssh keypair for rsync over ssh
      openssh_keypair:
        path: "{{ private_key_file.path }}"
        size: 2048
        force: true
      register: openssh_keypair

    - delegate_to: "{{ inventory_hostname }}"  # cancel previous delegate_to
      block:
        - name: Add public openssh key to admin's authorized_keys
          authorized_key:
            user: "{{ admin_user.name }}"
            state: present
            key: >-
              {{ openssh_keypair.public_key }}

    - name: Ensure destination directory for artifacts exists
      file:
        path: "{{ backup_destination_dir }}/"
        state: directory

    - name: Execute remote script via ssh and save its outputs locally
      shell: |
        set -o errexit -o nounset -o pipefail
        ssh -i $SSH_KEY_PATH $SSH_OPTIONS $SSH_USER@$SSH_HOST -- \
          '{{ inline_script }}' \
            1>$DESTINATION_FILE 2>$DESTINATION_FILE.sha1
        cd $DESTINATION_DIR/ && sha1sum -c $DESTINATION_FILE.sha1
      environment:
        SSH_KEY_PATH: "{{ private_key_file.path }}"
        SSH_OPTIONS: "-q -S none -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null"
        SSH_USER: "{{ admin_user.name }}"
        SSH_HOST: "{{ ansible_default_ipv4.address }}"
        DESTINATION_DIR: "{{ backup_destination_dir }}"
        DESTINATION_FILE: "{{ backup_destination_file }}"
      vars:
        # Variables from the environment array will not work here!
        inline_script: >-
          set -o errexit -o nounset -o pipefail;
          FIFO_PATH=$(mktemp -ud ~/fifo-XXXXXX);
          trap "rm -f $FIFO_PATH" EXIT;
          mkfifo $FIFO_PATH;
          (
            (sha1sum $FIFO_PATH | sed "s:[^ ]*$:{{ backup_destination_file | basename }}:") >&2 &
            ({{ backup_inline_script }}) | tee $FIFO_PATH;
            wait;
          );
      args:
        executable: /bin/bash
