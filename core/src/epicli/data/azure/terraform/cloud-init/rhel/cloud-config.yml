#cloud-config

# Modules run in the order given in /etc/cloud/cloud.cfg. You typically do not change this order.

# NOTE:
# 1) Do not use /mnt since it's used by Azure temporary disk.
# 2) RHEL 7 has bash v4.2 so nameref variables cannot be used.

# Log files:
# /var/log/cloud-init-output.log
# /var/log/cloud-init.log
# journalctl -u epiphany-lvm-merge

# Merge LV homelv as early as possible (when a user logs in, /home is in use and cannot be unmounted).

bootcmd:
# NOTE: Failure of a command neither stops the boot process nor next cloud-init modules.
# Merge LV homelv into rootlv, then remove homelv.
  - - bash
    - -ce
    - |
      append_unique_line_to_file() {
        local line="${1}"
        local file_path="${2}"

        if ! { test -f "$file_path" && grep -q -Fx "$line" "$file_path"; }; then
          run_shell_cmd "echo $line >> $file_path"
        fi
      }

      echo_info() {
        echo "info: ${*}"
      }

      get_enabled_services() {
        systemctl list-unit-files --type service --state enabled --no-legend --no-pager | awk '{print $1}'
      }

      get_non_masked_services() {
        systemctl list-unit-files --type service --no-legend --no-pager | grep -vw 'masked' | awk '{print $1}'
      }

      mask_service() {
        local service="${1}"
        local registry_file_path="${2}"

        if grep -q -Fx "$service" <(get_non_masked_services); then
          append_unique_line_to_file "$service" "$registry_file_path"
          run_cmd systemctl mask "$service"
        fi
      }

      merge_logical_volumes() {
        local lv_name="${1}"
        local target_lv_name="${2}"
        local mount_point="${3}"
        local state_file_path="${4}"

        local lv_path=/dev/mapper/rootvg-${lv_name}  # must correspond to the entry in /etc/fstab
        local target_lv_path=/dev/mapper/rootvg-${target_lv_name}
        local target_lv_mount_point=/${target_lv_name}-tmp-mnt  # do not use any location that may be a mount point such as /mnt or /tmp

        if lvs -o lv_name --noheadings | grep -q -w "$lv_name"; then
          if ! test -f "$state_file_path"; then
            run_cmd touch "$state_file_path"
          fi
          if findmnt --source "$lv_path" --target "$mount_point" > /dev/null; then
            echo_info "Found LV $lv_path mounted on $mount_point"
            echo_info "Will try to merge it into '${target_lv_name}'"
            run_cmd mount -v -o remount,ro "$mount_point"  # remount as read-only
            run_cmd mkdir -p "$target_lv_mount_point"
            run_cmd mount -v "$target_lv_path" "$target_lv_mount_point"
            run_cmd cp -ax "$mount_point" "$target_lv_mount_point"
            run_cmd umount -v "$mount_point"
          fi
          run_cmd sed -i "\|^${lv_path}[[:space:]]|d" /etc/fstab  # remove
          run_cmd systemctl daemon-reload  # to update mount units (systemd-fstab-generator)
          if lvs "$lv_path" -o lv_active --noheadings | grep -q -w 'active'; then
            run_cmd lvchange -v --activate n "$lv_path"  # deactivate
          fi
          run_cmd lvremove -v "$lv_path"
        fi
        # cleanups
        if findmnt --target "$target_lv_mount_point" > /dev/null; then
          run_cmd umount -v "$target_lv_mount_point"
        fi
        if test -d "$target_lv_mount_point"; then
          run_cmd rmdir "$target_lv_mount_point"
        fi
        if test -f "$state_file_path"; then
          run_cmd rm -f "$state_file_path"
        fi
      }

      # Prints string in format that can be reused as shell input escaping non-printable characters
      print_as_shell_input() {
        local -a escaped=()
        for arg in "$@"; do
          escaped+=( "$(printf '%q' "$arg")" )
        done
        if (( ${#escaped[@]} > 0 )); then
          printf '%s\n' "${escaped[*]}"
        fi
      }

      # Runs command as array with printing it, doesn't support commands with shell operators (such as pipe or redirection)
      run_cmd() {
        local -a cmd_arr=("$@")
        echo "run:" "$(print_as_shell_input "${cmd_arr[@]}")"
        "${cmd_arr[@]}"
      }

      # Runs command as string with printing it, supports commands with shell operators (such as pipe or redirection).
      # Note: eval constructs command by concatenating all arguments, quotes have to be escaped.
      run_shell_cmd() {
        local cmd_str="${*}"
        echo "run: $cmd_str"
        eval "$cmd_str"
      }

      save_enabled_services() {
        local output_file_path="${1}"
        run_shell_cmd "get_enabled_services > $output_file_path"
      }

      stop_service() {
        local service="${1}"
        local registry_file_path="${2}"

        if grep -q -Fx "$service" <(get_enabled_services); then
          append_unique_line_to_file "$service" "$registry_file_path"
          run_cmd systemctl stop "$service"
        fi
      }

      # --- main ---

      main() {
        # do not use location under mount point to be merged (such as /var) since it is temporarily remounted as read-only
        local work_dir_path=/root/epiphany-lvm-merge
        local state_file_path=${work_dir_path}/bootcmd.homelv-started.state
        export LVM_SUPPRESS_FD_WARNINGS=1  # to avoid warnings like 'File descriptor 5 (pipe:[19905]) leaked on lvs invocation'
        if lvs -o lv_name --noheadings | grep -q -w 'homelv' || test -f "$state_file_path"; then
          run_cmd mkdir -p "$work_dir_path"
          run_cmd merge_logical_volumes 'homelv' 'rootlv' '/home' "$state_file_path"
        fi

        # Optimization for varlv volume
        if lvs -o lv_name --noheadings | grep -q -w 'varlv'; then
         run_cmd mkdir -p "$work_dir_path"
          # Save list of enabled services to file in order to start temporarily disabled ones later
          local enabled_services_dump_path=${work_dir_path}/bootcmd.enabled-services.dump
          if ! test -f "$enabled_services_dump_path"; then
            save_enabled_services "$enabled_services_dump_path"
          fi
          # Disable kdump service if not started yet to save time in later part. It starts even when disabled so masking is used.
          local masked_services_registry_path=${work_dir_path}/bootcmd.masked-services.tmp-changes
          if grep -q -Fx 'kdump.service' \
          <(systemctl list-units --type=service --state=inactive --all --no-legend --no-pager | awk '{print $1}'); then
            mask_service 'kdump.service' "$masked_services_registry_path"
            run_cmd systemctl show 'kdump.service' -p LoadState,SubState
          fi
          # sssd.service is stopped because it causes issue on RHEL 8 due to caching local users in /var/lib/sss/mc/passwd
          local stopped_services_registry_path=${work_dir_path}/bootcmd.stopped-services.tmp-changes
          stop_service 'sssd.service' "$stopped_services_registry_path"
        fi
      }

      main

write_files:
  - path: /etc/systemd/system/epiphany-lvm-merge.service
    content: |
      [Unit]
      Description=Merge Azure provided LVM logical volumes into rootlv
      After=cloud-final.service
      # The following two directives require systemd >= v230. They are commented out to avoid warnings.
      # StartLimitBurst=3
      # StartLimitIntervalSec=300

      [Service]
      # Switch to 'Type=exec' with systemd >= v240
      Type=simple
      ExecStart=/usr/local/sbin/epiphany-lvm-merge.sh
      StandardOutput=journal+console
      Restart=on-failure
      RestartSec=5
      # for systemd < v230
      StartLimitBurst=3
      StartLimitInterval=300

      [Install]
      WantedBy=default.target

  - path: /usr/local/sbin/epiphany-lvm-merge-helper-functions.sh
    permissions: '0644'
    content: |
      #!/usr/bin/env bash
      # Common functions (not related to processing logic) for epiphany-lvm-merge.sh (in alphabetical order)

      append_array_to_file() {
        local file_path="${1}"
        shift
        local -a array=("$@")

        (( ${#array[@]} > 0 )) || return 64  # array cannot be empty

        # quote special characters for 'eval' in 'run_shell_cmd'
        readarray -t array < <(get_shell_escaped_array "${array[@]}")

        local -a cmd_arr=()
        cmd_arr+=("printf '%s\n'")
        cmd_arr+=("${array[@]}")
        cmd_arr+=(">> $file_path")

        # printing each item in new line is preferred since array may be long
        readarray -t cmd_arr < <(get_array_as_multiline_cmd "${cmd_arr[@]}")

        run_shell_cmd "$(printf '%s\n' "${cmd_arr[@]}")"
      }

      echo_info() {
        echo "info: ${*}"
      }

      get_all_services() {
        systemctl list-units --type=service --all --no-legend --no-pager | awk '{print $1}'
      }

      get_array_as_multiline_cmd() {
        local -a array=("$@")

        for i in "${!array[@]}"; do
          if (( ${#array[@]} > 1 )) && (( i < ${#array[@]}-1 )); then
            array[$i]="${array[$i]} \\"  # append ' \'
          fi
        done
        if (( ${#array[@]} > 0 )); then
          printf '%s\n' "${array[@]}"
        fi
      }

      get_running_services() {
        systemctl list-units --type=service --state=running --no-legend --no-pager | awk '{print $1}'
      }

      get_shell_escaped_array() {
        if (( $# > 0 )); then
          printf '%q\n' "$@"
        fi
      }

      is_in_array() {
        local item_to_search="${1}"
        shift
        local -a array=("$@")

        (( ${#array[@]} > 0 )) && grep -q -Fx "$item_to_search" <(printf '%s\n' "${array[@]}")
      }

      mount_logical_volume_to_directory() {
        local lv_path="${1}"  # e.g. /dev/mapper/rootvg-rootlv
        local mount_point="${2}"

        if ! findmnt --target "$mount_point" > /dev/null; then
          run_cmd mkdir -p "$mount_point"
          run_cmd mount -v "$lv_path" "$mount_point"
        fi
      }

      remove_files_if_exist() {
        local -a file_paths=("$@")

        for file in "${file_paths[@]}"; do
          if test -f "$file"; then
            run_cmd rm -f "$file"
          fi
        done
      }

      # Returns new array
      remove_item_from_array() {
        local item_to_remove="${1}"
        shift
        local -a input_arr=("$@")

        local -a output_arr=()
        for item in "${input_arr[@]}"; do
          [[ $item != "$item_to_remove" ]] && output_arr+=( "$item" )
        done
        if (( ${#output_arr[@]} > 0 )); then
          printf '%s\n' "${output_arr[@]}"
        fi
      }

      # Prints string in format that can be reused as shell input (escapes non-printable characters)
      print_array_as_shell_escaped_string() {
        local -a escaped
        readarray -t escaped < <(get_shell_escaped_array "$@")
        if (( ${#escaped[@]} > 0 )); then
          printf '%s\n' "${escaped[*]}"
        fi
      }

      # Runs command as array with printing it, doesn't support commands with shell operators (such as pipe or redirection)
      run_cmd() {
        local -a cmd_arr=("$@")
        echo "run:" "$(print_array_as_shell_escaped_string "${cmd_arr[@]}")"
        "${cmd_arr[@]}"
      }

      run_cmd_with_retries() {
        local retries="${1}"
        shift
        local -a cmd_arr=("$@")

        ( # sub-shell is used to limit scope for 'set +e'
          set +e
          for ((i=0; i <= retries; i++)); do
            run_cmd "${cmd_arr[@]}"
            return_code=$?
            if (( return_code == 0 )); then
              break
            elif (( i < retries )); then
              sleep 1
              echo "retrying ($(( i+1 ))/${retries})"
            else
              echo "ERROR: all attempts failed"
            fi
          done
          return $return_code
        )
      }

      # Runs command as string with printing it, supports commands with shell operators (such as pipe or redirection).
      # Note: eval constructs command by concatenating all arguments, quotes have to be escaped.
      run_shell_cmd() {
        local cmd_str="${*}"
        echo "run: $cmd_str"
        eval "$cmd_str"
      }

      start_services() {
        local -a services=("$@")
        local -i retries=3

        run_cmd_with_retries $retries systemctl start "${services[@]}"
      }

      stop_services() {
        local registry_file_path="${1}"  # stores list of services that are stopped by this function
        shift
        local services=("$@")

        (( ${#services[@]} > 0 )) || return 64

        append_array_to_file "$registry_file_path" "${services[@]}"

        # auditd requires specific command (service auditd stop). It's stopped as the last service by purpose.
        local stop_auditd=0
        if is_in_array 'auditd.service' "${services[@]}"; then
          stop_auditd=1
          readarray -t services < <(remove_item_from_array 'auditd.service' "${services[@]}")
        fi

        run_cmd systemctl stop "${services[@]}"

        if (( stop_auditd )); then
          run_cmd service auditd stop
        fi
      }

      unmask_services_from_file() {
        local file_path="${1}"

        local -a services_to_unmask
        readarray -t services_to_unmask < "$file_path"

        run_cmd systemctl unmask "${services_to_unmask[@]}"
      }

      unmount_directory() {
        local mount_point="${1}"
        local remove_dir="${2}"  # 0 -> false

        if findmnt --target "$mount_point" > /dev/null; then
          run_cmd umount -v "$mount_point"
        fi

        if (( remove_dir )) && test -d "$mount_point"; then
          run_cmd rmdir "$mount_point"
        fi
      }

      wait_for_files_to_be_closed() {
        local mount_point="${1}"
        local timeout="${2}"

        while lsof "$mount_point" > /dev/null; do
          echo_info "waiting for file(s) to be closed (timeout: $timeout)"
          run_cmd lsof "$mount_point" || true  # do not fail, this is just for logging
          run_cmd get_services_to_stop "$mount_point" 0 0  # do not apply exclusions and filtering
          if (( timeout > 0 )); then
            sleep 1
            (( timeout-- ))
          else
            echo "ERROR: timeout occurred"
            break  # non-fatal error, there is a chance that the next command (remount as read-only) will succeed
          fi
        done
      }

      wait_for_service_substate() {
        local service="${1}"
        local substate_extended_regex="${2}"
        local timeout="${3}"

        local substate='unknown'
        while ! grep -q -Ex "$substate_extended_regex" <(printf '%s\n' $substate); do
          substate=$(systemctl show "$service" -p SubState | cut -d'=' -f2)
          echo_info "waiting for substate to match '${substate_extended_regex}' (service: ${service%%.service}, substate: ${substate}, timeout: $timeout)"
          if (( timeout > 0 )); then
            sleep 1
            (( timeout-- ))
          else
            echo "ERROR: timeout occurred"
            return 124  # fatal error
          fi
        done
      }

      wait_for_services_to_exit() {
        local timeout="${1}"
        shift
        local services=("$@")

        for service in "${services[@]}"; do
          service="${service}.service"
          if grep -q -Fx "$service" <(get_all_services); then
            run_cmd wait_for_service_substate "$service" 'exited|failed|dead' "$timeout"
          fi
        done
      }

  - path: /usr/local/sbin/epiphany-lvm-merge-core-functions.sh
    permissions: '0644'
    content: |
      #!/usr/bin/env bash
      # Functions for epiphany-lvm-merge.sh (in alphabetical order)

      # shellcheck disable=SC1091
      source /usr/local/sbin/epiphany-lvm-merge-helper-functions.sh

      extend_logical_volume_to_use_free_space() {
        local vg_name="${1}"
        local lv_name="${2}"

        local lv_path=/dev/mapper/${vg_name}-${lv_name}
        local free_space
        free_space=$(vgs "$vg_name" -o free --noheadings)  # this may get a string, e.g. '<51.02g'
        if [[ $free_space != 0 ]]; then
          run_cmd lvextend --extents +100%FREE -v "$lv_path"
        fi
        # grow FS, it's safe to run this many times
        run_cmd xfs_growfs "$lv_path"
      }

      get_services_to_start() {
        local stopped_services_registry_file_path="${1}"

        local -a services_to_start
        if test -f "$stopped_services_registry_file_path"; then
          readarray -t services_to_start < <(grep -Fxv -f <(get_running_services) "$stopped_services_registry_file_path")
        fi
        if (( ${#services_to_start[@]} > 0 )); then
          printf '%s\n' "${services_to_start[@]}" | sort --ignore-case
        fi
      }

      # Gets services that currently use files under a mount point or should be stopped
      get_services_to_stop() {
        local mount_point="${1}"
        local apply_exclusions="${2:-1}"  # 1 -> true
        local apply_filtering="${3:-1}"

        local -a pids_to_stop services_to_stop
        # get PIDs that use files under mount point
        readarray -t pids_to_stop < <(lsof -t "${mount_point}")
        if (( ${#pids_to_stop[@]} > 0 )); then
          # shellcheck disable=SC2009
          readarray -t services_to_stop < \
            <(ps -o 'unit' --no-headers --pid "${pids_to_stop[@]}" | sort --ignore-case | uniq)
          if (( apply_filtering )) && (( ${#services_to_stop[@]} > 0 )); then
            readarray -t services_to_stop < <(grep '\.service$' <(printf '%s\n' "${services_to_stop[@]}"))
          fi
        fi
        # additional services to stop if present and running (e.g. lsof doesn't detect chronyd)
        local -a additional_services_to_stop=()
        case $mount_point in
          /tmp)
            additional_services_to_stop=(chronyd firewalld systemd-hostnamed systemd-resolved)  # systemd-resolved added for RHEL 8
            ;;
          /var)
            additional_services_to_stop=(abrt-oops chronyd crond rhsmcertd systemd-hostnamed systemd-resolved waagent)  # systemd-resolved added for RHEL 8
            ;;
        esac
        if (( ${#additional_services_to_stop[@]} > 0 )); then
          for service in "${additional_services_to_stop[@]}"; do
            service="${service}.service"
            if grep -q -w 'running' <(systemctl show -p SubState "$service") \
            && ! is_in_array "$service" "${services_to_stop[@]}"; then
              services_to_stop+=("$service")
            fi
          done
        fi
        if (( apply_exclusions )); then
          # it seems it's safer to wait for kdump to exit than stopping it
          local -a excluded_services=(epiphany-lvm-merge kdump sshd)
          for service in "${excluded_services[@]}"; do
            service="${service}.service"
            if is_in_array "$service" "${services_to_stop[@]}"; then
              readarray -t services_to_stop < <(remove_item_from_array "$service" "${services_to_stop[@]}")
            fi
          done
        fi
        # some services after stopping are activated by sockets
        local -A sockets_to_stop  # sockets_to_stop[<service_name>]="<socket_1> [socket_2]"
        sockets_to_stop[dbus]="dbus"  # bash does not support multi-dimensional arrays
        sockets_to_stop[systemd-udevd]="systemd-udevd-control systemd-udevd-kernel"
        for service in "${!sockets_to_stop[@]}"; do
          if is_in_array "${service}.service" "${services_to_stop[@]}"; then
            for socket in ${sockets_to_stop["$service"]}; do  # do not use quotes here
              if grep -q -w 'running' <(systemctl show -p SubState "${socket}.socket"); then
                services_to_stop+=("${socket}.socket")
              fi
            done
          fi
        done
        if (( ${#services_to_stop[@]} > 0 )); then
          printf '%s\n' "${services_to_stop[@]}" | sort --ignore-case
        fi
      }

      merge_logical_volumes() {
        local lv_name="${1}"
        local target_lv_name="${2}"
        local mount_point="${3}"
        local target_lv_mount_point="${4}"

        local lv_path=/dev/mapper/rootvg-${lv_name}  # must correspond to the entry in /etc/fstab
        local state_file_path=/var/tmp/epiphany-lvm-merge-${lv_name}-started.state
        # do not use location under mount point to be merged such as /var since it is temporarily remounted as read-only
        local stopped_services_registry_file_path=/root/epiphany-lvm-merge.${lv_name}.stopped-services.tmp-changes

        export LVM_SUPPRESS_FD_WARNINGS=1
        if lvs "$lv_path" > /dev/null; then
          if ! test -f "$state_file_path"; then
            run_cmd touch "$state_file_path"
          fi
          if findmnt --source "$lv_path" --target "$mount_point" > /dev/null; then
            echo_info "Found LV $lv_path mounted on $mount_point"
            echo_info "Will try to merge it into '${target_lv_name}'"
            if [[ $mount_point = /var ]]; then
              # Wait for kdump.service to exit, just in case it was started.
              # Process plymouthd writes to /var/log/boot.log. It's started by plymouth-start.service
              # and stopped by plymouth-quit-wait.service. It seems it's safer to wait for it to exit than stopping it.
              wait_for_services_to_exit 120 'kdump' 'plymouth-start'
            fi
            local -a services_to_stop
            readarray -t services_to_stop < <(get_services_to_stop "$mount_point")
            if (( ${#services_to_stop[@]} > 0 )); then
              stop_services "$stopped_services_registry_file_path" "${services_to_stop[@]}"
            fi
            run_cmd wait_for_files_to_be_closed "$mount_point" 30
            run_cmd_with_retries 3 mount -v -o remount,ro "$mount_point"  # remount as read-only
            run_cmd cp -ax "$mount_point" "$target_lv_mount_point"
            run_cmd umount -v "$mount_point"
          fi
          run_cmd sed -i "\|^${lv_path}[[:space:]]|d" /etc/fstab  # remove
          run_cmd systemctl daemon-reload  # to update mount units (systemd-fstab-generator)
          if lvs "$lv_path" -o lv_active --noheadings | grep -q -w 'active'; then
            local debug_cmd="grep '$lv_name' /proc/*/mounts | grep -Po '(?<=/proc/)\d+' | xargs -i awk 1 /proc/{}/cmdline | uniq"
            run_cmd_with_retries 3 lvchange -v --activate n "$lv_path" || run_shell_cmd "$debug_cmd"
          fi
          run_cmd lvremove -v "$lv_path"
          local -a services_to_start
          readarray -t services_to_start < <(get_services_to_start "$stopped_services_registry_file_path")
          if (( ${#services_to_start[@]} > 0 )); then
            start_services "${services_to_start[@]}"
          fi
        fi
        # cleanup
        remove_files_if_exist "$stopped_services_registry_file_path" "$state_file_path"
      }

      restore_disabled_services() {
        local enabled_services_dump_path="${1}"
        local masked_services_registry_file_path="${2}"

        # unmask
        if test -f "$masked_services_registry_file_path"; then
          unmask_services_from_file "$masked_services_registry_file_path"
          # start
          if test -f "$enabled_services_dump_path"; then
            local -a services_to_start
            readarray -t services_to_start < \
              <(grep -Fx -f "$masked_services_registry_file_path" "$enabled_services_dump_path")
            if (( ${#services_to_start[@]} > 0 )); then
              # start kdump without waiting for it to save time
              if is_in_array 'kdump.service' "${services_to_start[@]}"; then
                run_cmd systemctl start --no-block kdump.service
                readarray -t services_to_start < <(remove_item_from_array 'kdump.service' "${services_to_start[@]}")
              fi
              if (( ${#services_to_start[@]} > 0 )); then
                run_cmd_with_retries 3 systemctl start "${services_to_start[@]}"
              fi
            fi
            run_cmd rm -f "$enabled_services_dump_path"
          fi
          run_cmd rm -f "$masked_services_registry_file_path"
        fi
      }

      restore_stopped_services() {
        local stopped_services_registry_file_path="${1}"

        if test -f "$stopped_services_registry_file_path"; then
          local -a services_to_start
          readarray -t services_to_start < "$stopped_services_registry_file_path"
          if (( ${#services_to_start[@]} > 0 )); then
            run_cmd_with_retries 3 systemctl start "${services_to_start[@]}"
          fi
          run_cmd rm -f "$stopped_services_registry_file_path"
        fi
      }

  - path: /usr/local/sbin/epiphany-lvm-merge.sh
    permissions: '0755'
    content: |
      #!/usr/bin/env bash

      set -o errexit -o nounset -o pipefail

      echo "*** Starting script: $0 at $(date +"%T.%N")"

      # shellcheck disable=SC1091
      source /usr/local/sbin/epiphany-lvm-merge-core-functions.sh

      main() {
        # do not use location under mount point to be merged (such as /var) since it is temporarily remounted as read-only
        local work_dir_path=/root/epiphany-lvm-merge

        local -A volumes_to_merge
        # homelv is already merged by bootcmd
        # usrlv will be not merged because it requires reboot
        volumes_to_merge[optlv]=/opt
        volumes_to_merge[tmplv]=/tmp
        volumes_to_merge[varlv]=/var

        # If this file exists it means the process was started but not completed
        local state_flag_file=${work_dir_path}/uncompleted

        if ! lvs -o lv_name --noheadings | grep -qw -f <(printf '%s\n' "${!volumes_to_merge[@]}") \
        && ! test -f $state_flag_file; then
          echo "*** Nothing to do, exiting"
          exit 0
        fi

        run_cmd mkdir -p "$work_dir_path"
        test -f $state_flag_file || run_cmd touch $state_flag_file

        # wait until cloud-init is done
        run_cmd cloud-init status --wait

        # this mount point is temporary, do not use any location that may be a mount point such as /mnt or /tmp
        local rootlv_aux_mount_point=${work_dir_path}/rootlv-mnt
        run_cmd mount_logical_volume_to_directory '/dev/mapper/rootvg-rootlv' "$rootlv_aux_mount_point"

        # merge volumes
        local -a volumes_in_order  # merge varlv as the last to save time
        readarray -t volumes_in_order < <(printf '%s\n' "${!volumes_to_merge[@]}" | sort)
        for volume in "${volumes_in_order[@]}"; do
          run_cmd merge_logical_volumes "$volume" 'rootlv' "${volumes_to_merge[$volume]}" "$rootlv_aux_mount_point"
        done

        run_cmd extend_logical_volume_to_use_free_space 'rootvg' 'rootlv'

        # these files are created using cloud-init (module bootcmd)
        local enabled_services_dump_path=${work_dir_path}/bootcmd.enabled-services.dump
        local masked_services_registry_path=${work_dir_path}/bootcmd.masked-services.tmp-changes
        local stopped_services_registry_path=${work_dir_path}/bootcmd.stopped-services.tmp-changes

        restore_disabled_services $enabled_services_dump_path $masked_services_registry_path
        restore_stopped_services $stopped_services_registry_path

        # cleanups
        unmount_directory "$rootlv_aux_mount_point" 1  # with directory removal
        remove_files_if_exist "$state_flag_file"
        run_cmd rmdir "$work_dir_path"

        run_cmd systemctl disable epiphany-lvm-merge.service  # disable itself

        echo "*** Finished script: $0 at $(date +"%T.%N")"
        echo "*** Elapsed time: $(((SECONDS / 60) % 60))min $((SECONDS % 60))s"
      }

      main

# runcmd only runs during the first boot
runcmd:
  - systemctl enable epiphany-lvm-merge
  - systemctl start --no-block epiphany-lvm-merge
